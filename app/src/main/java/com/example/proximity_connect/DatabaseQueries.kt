/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.example.proximity_connect

import java.sql.Connection
import java.sql.DriverManager

class DatabaseQueries {
    var PCDatabase: Connection? = null

    /*
     * Constructs the class and connects to the database
     */
    init {
        val url = "jdbc:mysql://98.166.255.71:3306/proximity_connect"
        val username = "YellowTeam"
        val password = "Yellow411w"
        try {
            PCDatabase = DriverManager.getConnection(url, username, password)
        } catch (e: Exception) {
            println(e)
        }
    }

    /*
     * ---------------------------------------------------------------------------
     *                             User Functions
     * ---------------------------------------------------------------------------
     */
    /*
     * Adds a new user for to the database
     *  
     * @param id            an int that uniquely identifies the new user
     * @param email         the users email that will be userd to login
     * @param phonenumber   the users phone number to associate with the acount
     * @param password      the password the user will use to login
     * @param date the      date the user was created formated "yyyy-mm-dd"
     */
    fun AddUser(
        email: String,
        phonenumber: String,
        username: String,
        password: String,
        Date: String
    ) {
        val id = email.hashCode()
        try {
            PCDatabase!!.createStatement()
                .execute("insert into users (user_id, email, phonenumber, username, user_password, created_at) values($id, \'$email\', \'$phonenumber\', \'$username\', \'$password\', \'$Date\')")
        } catch (e: Exception) {
            println("AddUser Error:\n    $e")
        }
        defaultSettings(id)
    }

    val nextUserID: Int
        /*
     * -------------------------Depericated---------------------------
     * Querries the database to find the next available ID for a User 
     * 
     * @return      the next avalible user_id as an int
     */
        get() {
            try {
                val results =
                    PCDatabase!!.createStatement().executeQuery("select max(user_id) from users")
                return if (results.next()) results.getInt(1) + 1 else 1
            } catch (e: Exception) {
                println("GetNextUserID Error:\n    $e")
            }
            return -1
        }

    /*
     * Querries the database to validate login information
     *  
     * @param email     the email of the user trying to login
     * @param password  the password associated with the userID
     * @return          the user_id if password matches the stored password or -1 on a failed login attempt
     */
    fun Login(email: String, password: String): Int {
        try {
            val results = PCDatabase!!.createStatement()
                .executeQuery("select user_id from users where email=\'$email\' and user_password=\'$password\'")
            if (results.next()) return results.getInt("user_id")
        } catch (e: Exception) {
            println("Login Error:\n    $e")
        }
        return -1
    }

    /*
     * Changes password of the user in the database given the user_id and oldPassword matches
     * in the database
     *  
     * @param user_id       the id of the user modifying their password
     * @param oldPassword   the password stored in the database
     * @param newPassword   the password that will replace the one in the database
     */
    fun updatePassword(user_id: Int, oldPassword: String, newPassword: String) {
        try {
            PCDatabase!!.createStatement()
                .execute("update users set user_password=\'$newPassword\' where user_id=$user_id and user_password=\'$oldPassword\'")
        } catch (e: Exception) {
            println("updatePassword Error:\n    $e")
        }
    }

    /*
     * Creates default usersettings in the database for a given user id
     *  
     * @param UID   the userid to create the default settings for
     */
    fun defaultSettings(UID: Int) {
        try {
            PCDatabase!!.createStatement()
                .execute("insert into user_settings (user_id, UI_color, UI_Font, first_name, last_name, primary_language) values ($UID, \'(255, 255, 255)\', \'Times New Roman\', \'FirstName\', \'LastName\',\'English\')")
        } catch (e: Exception) {
            println("defaultSettings Error:\n    $e")
        }
    }

    /*
     * Changes the user settings to the given values
     *  
     * @param UID                   the id of the user for which the settings are being updated
     * @param color                 the new color of the UI formated "(r,g,b)"
     * @param Font                  the font to be used for the UI
     * @param Fname                 the first name of the user
     * @param Lname                 the last name of the user
     * @param primary_language      the primary language spoken by the user
     */
    fun updateUserSettings(
        UID: Int,
        color: String,
        Font: String,
        Fname: String,
        LName: String,
        primary_language: String
    ) {
        try {
            PCDatabase!!.createStatement()
                .execute("update user_settings set UI_color=\'$color\', UI_Font=\'$Font\', first_name=\'$Fname\', last_name=\'$LName\', primary_language=\'$primary_language\' where user_id=$UID")
        } catch (e: Exception) {
            println("updateUserSettings Error:\n    $e")
        }
    }

    /*
     * ---------------------------------------------------------------------------
     *                             Group Functions
     * ---------------------------------------------------------------------------
     */
    /*
     * Querries the database for the next avalible group id
     * 
     * @return      the next unused group_id
    */
    fun nextGroupID(): Int {
        try {
            val results =
                PCDatabase!!.createStatement().executeQuery("select max(group_id) from user_group")
            return if (results.next()) results.getInt(1) + 1 else 1
        } catch (e: Exception) {
            println("GetNextGroupID Error:\n    $e")
        }
        return -1
    }

    /*
     * Creates a new group in the database
     * 
     * @param groupID       the groupID of the new group to be created
     * @param name          the name of the group
     * @param creatorID     the id of the user who made the group
     */
    fun CreateGroup(groupID: Int, name: String, creatorID: Int) {
        try {
            PCDatabase!!.createStatement()
                .execute("insert into user_group (group_id, group_name, group_creator) values ($groupID, \'$name\', $creatorID)")
            PCDatabase!!.createStatement()
                .execute("insert into group_members (group_id, user_id) values ($groupID, $creatorID)")
        } catch (e: Exception) {
            println("CreateGroup Error:\n    $e")
        }
    }

    /*
     * Adds a user to a group within the database
     * 
     * @param groupID   the id of the group that will receive the new member
     * @param userID    the id of the user that will be added to the group
     */
    fun addGroupMember(groupID: Int, userID: Int) {
        try {
            PCDatabase!!.createStatement()
                .execute("insert into group_members (user_id, group_id) values ($userID, $groupID)")
        } catch (e: Exception) {
            println("CreateGroup Error:\n    $e")
        }
    }

    /*
     * Returns an int[] of the groups a given user is in
     * 
     * @param user_id   the user to querry the database for
     * @return          the list of group ids the user is a member of
     */
    fun getGroups(user_id: Int): IntArray? {
        try {
            val len = PCDatabase!!.createStatement()
                .executeQuery("select count(group_id) from group_members where user_id=$user_id")
            val group_values: IntArray
            group_values = if (len.next()) {
                IntArray(len.getInt(1))
            } else {
                return null
            }
            val groups = PCDatabase!!.createStatement()
                .executeQuery("select group_id from group_members where user_id=$user_id")
            var i = 0
            while (groups.next()) {
                group_values[i] = groups.getInt("group_id")
                i++
            }
            return group_values
        } catch (e: Exception) {
            println("getGroups Error:\n    $e")
        }
        return null
    }

    /*
     * Returns an int[] of the users that are a memeber of a given group
     * 
     * @param group_id  the group id to querry the database for
     * @return          the list of user ids that are a member of the group
     */
    fun getGroupMembers(group_id: Int): IntArray? {
        try {
            val len = PCDatabase!!.createStatement()
                .executeQuery("select count(user_id) from group_members where group_id=$group_id")
            val members: IntArray
            members = if (len.next()) {
                IntArray(len.getInt(1))
            } else {
                return null
            }
            val Members = PCDatabase!!.createStatement()
                .executeQuery("select user_id from group_members where group_id=$group_id")
            var i = 0
            while (Members.next()) {
                members[i] = Members.getInt("user_id")
                i++
            }
            return members
        } catch (e: Exception) {
            println("getGroupMembers Error:\n    $e")
        }
        return null
    }

    /*
     * Removes a user from the group excluding creator
     * 
     * @param group_id  the group id to remove the given user from
     * @param user_id   the user id to remove from the group
     */
    fun removeUserFromGroup(group_id: Int, user_id: Int) {
        try {
            if (getGroupCreator(group_id) != user_id) PCDatabase!!.createStatement()
                .execute("delete from group_members where user_id=$user_id and group_id=$group_id")
        } catch (e: Exception) {
            println("removeUserFromGroup Error:\n    $e")
        }
    }

    /*
     * Returns a string of the name for the group with the given id
     * 
     * @param group_id  the group id to get the name of
     * @return          the name of the group with the given id or, if the id is not found, an empty string
     */
    fun getGroupName(group_id: Int): String {
        try {
            val groupName = PCDatabase!!.createStatement()
                .executeQuery("select group_name from user_group where group_id=$group_id")
            groupName.next()
            return groupName.getString("group_name")
        } catch (e: Exception) {
            println("removeGetGroupName Error:\n    $e")
        }
        return ""
    }

    /*
     * Returns an int of the creator of the group with the given id
     * 
     * @param group_id  the group id to get the creator of
     * @return          the creator of the group with the given id or, if the id is not found, -1
     */
    fun getGroupCreator(group_id: Int): Int {
        try {
            val groupName = PCDatabase!!.createStatement()
                .executeQuery("select group_creator from user_group where group_id=$group_id")
            groupName.next()
            return groupName.getInt("group_creator")
        } catch (e: Exception) {
            println("removeGetGroupCreator Error:\n    $e")
        }
        return -1
    }

    val nextMeetingID: Int
        /*
     * ---------------------------------------------------------------------------
     *                             Meeting Functions
     * ---------------------------------------------------------------------------
     */
        get() {
            try {
                val results = PCDatabase!!.createStatement()
                    .executeQuery("select max(meeting_id) from group_meetings")
                return if (results.next()) results.getInt(1) + 1 else 1
            } catch (e: Exception) {
                println("getNextMeetingID Error:\n    $e")
            }
            return -1
        }

    /*
     * Creates a new meeting with in the database
     * 
     * @param meeting_id        the unique id of the meeting
     * @param group_id          the id of the group having the meeting
     * @param meeting_name      the name of the meeting
     * @param dateTime          the date and time the meeting took place formated as "yyyy-mm-dd hh:mm:ss"
     * @param shareable         a boolean determining if a meeting can be shared beyond the group
     */
    fun CreateMeeting(
        meeting_id: Int,
        group_id: Int,
        meeting_name: String,
        dateTime: String,
        shareable: Boolean
    ) {
        try {
            PCDatabase!!.createStatement()
                .execute("insert into group_meetings (group_id, meeting_id, meeting_name, meeting_date, shareable) values ($group_id, $meeting_id, \'$meeting_name\', \'$dateTime\', $shareable)")
        } catch (e: Exception) {
            println("CreateMeeting Error:\n    $e")
        }
    }

    /*
     * Returns an int[] of the meetings a group has held
     * 
     * @param group_id      the id of the group to querry the database for
     * @return              the list of meeting ids that have been held by the given group
     */
    fun getGroupMeetings(group_id: Int): IntArray? {
        try {
            val len = PCDatabase!!.createStatement()
                .executeQuery("select count(meeting_id) from group_meetings where group_id=$group_id")
            val meetings: IntArray
            meetings = if (len.next()) {
                IntArray(len.getInt(1))
            } else {
                return null
            }
            val Meetings = PCDatabase!!.createStatement()
                .executeQuery("select meeting_id from group_meetings where group_id=$group_id")
            var i = 0
            while (Meetings.next()) {
                meetings[i] = Meetings.getInt("meeting_id")
                i++
            }
            return meetings
        } catch (e: Exception) {
            println("getGroupMembers Error:\n    $e")
        }
        return null
    }

    /*
     * ---------------------------------------------------------------------------
     *                             Message Functions
     * ---------------------------------------------------------------------------
     */
    /*
     * Returns an int for the next message id avalible within a meeting
     * 
     * @param meeting_id    the id of the meeting this message id will be a part of
     * @return              the next avalible id for a message
     */
    fun getNextMessageID(meeting_id: Int): Int {
        try {
            val results = PCDatabase!!.createStatement()
                .executeQuery("select max(message_id) from messages where meeting_id=$meeting_id")
            return if (results.next()) results.getInt(1) + 1 else 1
        } catch (e: Exception) {
            println("getNextMessageID Error:\n    $e")
        }
        return -1
    }

    /*
     * Creates a message within the database
     * 
     * @param user_id       the id of the user who created the message
     * @param meeting_id    the id of the meeting this message is a part of
     * @param message_id    the id of the message (note: within the database a message must have a unique pair of meeting id and message id)
     * @param message       the contents of the message
     * @param dateTime      the date and time the message was made formated as "yyyy-mm-dd hh:mm:ss"
     */
    fun createMessage(
        user_id: Int,
        meeting_id: Int,
        message_id: Int,
        message: String,
        dateTime: String,
        pinned: Boolean
    ) {
        try {
            PCDatabase!!.createStatement()
                .execute("insert into messages (user_id, meeting_id, message_id, body, created_at, pinned) values ($user_id, $meeting_id, $message_id, \'$message\', \'$dateTime\', $pinned)")
        } catch (e: Exception) {
            println("CreateMessage Error:\n    $e")
        }
    }

    /*
     * Updates the pinned entry for a message inside the database
     * 
     * @param meeting_id    the id of the meeting the message belongs to
     * @param message_id    the id of the message to be updated
     * @param pinned        the new pinned status for a message
     */
    fun messageSetPinned(meeting_id: Int, message_id: Int, pinned: Boolean) {
        try {
            PCDatabase!!.createStatement()
                .execute("update messages set pinned=\'$pinned\' where meeting_id=$meeting_id and message_id=$message_id")
        } catch (e: Exception) {
            println("messageSetPinned Error:\n    $e")
        }
    }

    /*
     * Returns an int[] of the pinned messages within a meeting
     * 
     * @param meeting_id    the id of the meeting to search
     * @return              the messages of the meeting where pinned is true
     */
    fun getPinnedMessages(meeting_id: Int): IntArray? {
        try {
            val len = PCDatabase!!.createStatement()
                .executeQuery("select count(message_id) from messages where pinned='true' and meeting_id=$meeting_id")
            val messages: IntArray
            messages = if (len.next()) {
                IntArray(len.getInt(1))
            } else {
                return null
            }
            val pinnedMessages = PCDatabase!!.createStatement()
                .executeQuery("select message_id from messages where pinned='true' and meeting_id=$meeting_id")
            var i = 0
            while (pinnedMessages.next()) {
                messages[i] = pinnedMessages.getInt("message_id")
                i++
            }
            return messages
        } catch (e: Exception) {
            println("getPinnedMessages Error:\n    $e")
        }
        return null
    }
}
